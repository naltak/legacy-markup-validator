#!/usr/local/bin/perl -w
#
# W3C HTML Validation Service
# A CGI script to retrieve and validate an HTML file
#
# Copyright 1995-2001 Gerald Oskoboiny <gerald@w3.org>
# for additional contributors, see http://dev.w3.org/cvsweb/validator/
#
# This source code is available under the license at:
#     http://www.w3.org/Consortium/Legal/copyright-software
#
# $Id: check,v 1.162 2001-07-25 00:37:11 link Exp $

#
# We need Perl 5.004.
require 5.004;

#
# Load modules
use strict;
use LWP::UserAgent;
use URI;
use URI::Escape;
use CGI::Carp;
use CGI qw(:cgi -newstyle_urls -private_tempfiles);
use Text::Wrap;
use Text::Iconv;
use HTML::Parser 3.25; # Need 3.25 for $p->ignore_elements.


#############################################################################
# Constant definitions
#############################################################################

#
# Define global constants
use constant TRUE  => 1;
use constant FALSE => 0;
use constant UNDEF => undef;
use constant DEBUG => 0;

#
# Define global variables
use vars qw($VERSION $DATE $MAINTAINER $NOTICE);               # Strings.
use vars qw($frag $pub_ids $element_uri $file_type $doctypes $charsets);
                                                               # Cfg hashes.
use vars qw($DEBUG); # Switch to turn debugging on and off.
use vars qw($File);  # Global var to hold all metadata for this validation.

$DEBUG += 1 unless $ENV{SERVER_PORT} == 80;

#
# Paths and file locations
my $base_path = $0;  # get full name of program
   $base_path =~ s#^(/([^/]*/)*)[^/]*/[^/]*/[^/]*$#$1#; # move two levels up
        # backtracking is somewhat inefficient, but nothing to worry

my $html_path = $base_path . 'htdocs/';
my $elem_db   = $html_path . 'config/eref.cfg';
my $fpis_db   = $html_path . 'config/fpis.cfg';
my $frag_db   = $html_path . 'config/frag.cfg';
my $type_db   = $html_path . 'config/type.cfg';
my $dtds_db   = $html_path . 'config/doctypes.cfg';
my $chst_db   = $html_path . 'config/charset.cfg';
my $sgmlstuff = $html_path . 'sgml-lib';
my $temp      = "/tmp/validate.$$"; # @@ Use POSIX/IO::File tmpfiles instead!

#
# Executables and binaries
my $sp  = '/usr/local/bin/lq-nsgmls';
my $osp = '/usr/local/bin/onsgmls';

#
# URIs and fragments
my $abs_svc_uri	= 'http://validator.w3.org/';
my $uri_def_uri	= 'http://www.w3.org/Addressing/#terms';
my $faqloc	= '/docs/';
my $faqerrloc	= $faqloc . 'errors.html';
my $element_ref = 'http://www.htmlhelp.com/reference/html40/';

#
# Strings
$VERSION    =  q$Revision: 1.162 $;
$VERSION    =~ s/Revision: ([\d\.]+) /$1/;
$DATE       =  q$Date: 2001-07-25 00:37:11 $;
$MAINTAINER =  'gerald@w3.org';
$NOTICE     =  ''; # "<p><strong>Note: This service will be ...</strong>";

#
# DOCTYPEs
my $html32_doctype  = q(<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">);
my $html40s_doctype = q(<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/1999/REC-html401-19991224/strict.dtd">);
my $html40t_doctype = q(<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">);
my $html40f_doctype = q(<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/1999/REC-html401-19991224/frameset.dtd">);
my $xhtmlt_doctype  = q(<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN");

#
# Read configuration files.
$frag        = &read_cfg($frag_db); # FPIs    -> plain text version string
$pub_ids     = &read_cfg($fpis_db); # Errors  -> fragment identifier
$element_uri = &read_cfg($elem_db); # Element -> URI fragment
$file_type   = &read_cfg($type_db); # Content -> File -type
$doctypes    = &read_cfg($dtds_db); # Name    -> doctype
$charsets    = &read_cfg($chst_db); # charset -> iconv parameter

#
# Set up signal handlers.
$SIG{TERM} = \&erase_stuff;
$SIG{KILL} = \&erase_stuff;
$SIG{PIPE} = 'IGNORE';

#
# delete() the, possibly tainted, $PATH.
delete $ENV{PATH};


#############################################################################
# Process CGI variables
#############################################################################

#
# Create a new CGI object.
my $q = new CGI;

#
# Backwards compatibility; see
# http://lists.w3.org/Archives/Public/www-validator/1999JulSep/0197
# http://lists.w3.org/Archives/Public/www-validator/1999JulSep/0212
if (scalar $q->param) {
  foreach my $param ($q->param) {
    $q->param($param, TRUE) unless $q->param($param);
  }
}

#
# Futz the URI so "/referer" works.
if ($q->path_info eq '/referer') {
  $q->param('uri', $q->referer);
}

#
# USe HTTP Referer if uri=referer.
if ($q->param('uri') =~ m(referer)i) {
  $q->param('uri', $q->referer);
}

#
# Use "url" unless a "uri" was also given.
if ($q->param('url') and not $q->param('uri')) {
  $q->param('uri', $q->param('url'));
}

#
# Supercede URI with an uploaded file.
if ($q->param('uploaded_file')) {
  &redirect_to_home_page unless length($q->param('uploaded_file')); # Must have filename.
  $q->param('uri', 'upload://' . $q->param('uploaded_file'));
}

#
# Supercede URI with an uploaded fragment.
if ($q->param('fragment')) {$q->param('uri', 'upload://Form Submission')};

#
# Send them to the homepage unless we can extract a URI from either of the
# acceptable sources: uri, url or /referer.
&redirect_to_home_page unless length($q->param('uri')) > 5;

#
# Munge the URI to include commonly omitted prefix.
$q->param('uri', 'http://' . $q->param('uri')) if $q->param('uri') =~ m(^www)i;


#############################################################################
# Output validation results
#############################################################################

#
# A string containing the HTML header for validation results.
# We save it in a string instead of printing it in case we need to abort before
# we have any meaningfull results to report. @@ May not be necessary!
$File->{Results} = <<"EOF";
Content-Type: text/html; charset=utf-8

$html40t_doctype
<html>
  <head>
    <title>W3C HTML Validation Service Results</title>
    <link rev="made" href="mailto:$MAINTAINER">
    <link rel="stylesheet" href="/results.css" media="screen">
  </head>

  <body bgcolor="#FFFFFF" text="#000000" link="#0000ee" vlink="#551a8b">
    <h1 class="title"><a href="http://www.w3.org/"><img
       src="http://www.w3.org/Icons/WWW/w3c_home"
       width=72 height=48 border="0" alt="W3C"></a>
      <a href="/">HTML Validation Service</a> Results</h1>
    $NOTICE
EOF


#
# Punt if we don't recognize this URI scheme.
# @@ LWP does a whole bunch more: transparently!
unless ($q->param('uri') =~ m(^(http|upload)://)) {
  print $File->{Results};
  print <<"EOF";
  <p>
    Sorry, this type of <a href="http://www.w3.org/Addressing/#terms">URI</a>
    is not supported by this service.
  </p>
  <p>
    URIs should be in the form:
  </p>
  <blockquote>
    <code>$abs_svc_uri</code>
  </blockquote>
  <p>
    (There are other types of URIs, too, but only <code>http://</code> URIs
    are currently supported by this service.)
  </p>
EOF
  &clean_up_and_exit;
}

#
# Get the file and metadata.
if    ($q->param('uploaded_file')) {$File = &handle_file($q, $File)}
elsif ($q->param('fragment'))      {$File = &handle_frag($q, $File)}
elsif ($q->param('uri'))           {$File = &handle_uri( $q, $File)};

#
# Abort if there was no document type mapping for this Content-Type, in which
# case the document type will be equal to the content type (contains a "/").
if ($File->{'Type'} =~ m(/) and not $q->param('uploaded_file')) {
  print $File->{Results};
  print <<"EOF";
    <p class="error">
      Sorry, I am unable to validate this document because its returned
      content-type was <code>$File->{Type}</code>, which is not
      currently supported by this service.
    </p>
EOF
  &clean_up_and_exit;
}

#
# Overall parsing algorithm for documents returned as text/html:
#
# For documents that come to us as text/html,
#
#  1. check if there's a doctype
#  2. if there is a doctype, parse/validate against that DTD
#  3. if no doctype, check for an xmlns= attribute on the first element
#  4. if there is an xmlns= attribute, check for XML well-formedness
#  5. if there is no xmlns= attribute, and no DOCTYPE, punt.
#

#
# Detect and remove a UTF-8 BOM.
$File->{Content}[0] =~ s/^\xEF\xBB\xBF//
  and &add_warning(<<".EOF.");
     UTF-8 'BOM' detected and removed. (See the
     <a href="$faqerrloc#utf8-bom">explanation</a> for details.)
.EOF.


#
# Override DOCTYPE if user asked for it.
if (defined $q->param('doctype') and not $q->param('doctype') =~ /Inline/i) {
  $File->{Content} = &supress_doctype($File->{Content});
  unshift @{$File->{Content}}, $doctypes->{$q->param('doctype')};
  my $dtd = ent($q->param('doctype'));
  &add_warning(<<".EOF.");
  <strong>DOCTYPE Override in effect!</strong> Any DOCTYPE Declaration in the
  document has been supressed and the DOCTYPE for &#171;<code>$dtd</code>&#187;
  inserted instead. The document will not be Valid until you alter the source
  file to reflect this new DOCTYPE.
.EOF.
  $File->{Tentative} = TRUE; # Tag it as Invalid.
}

#
# Try to extract a DOCTYPE or xmlns.
$File = &preparse($File);


#
# Set document type to XHTML if the DOCTYPE was for XHTML.
# Set document type to MathML if the DOCTYPE was for MathML.
# This happens when the file is served as text/html
$File->{Type} = 'xhtml'  if $File->{DOCTYPE} =~ /xhtml/i;
$File->{Type} = 'mathml' if $File->{DOCTYPE} =~ /mathml/i;


# If we have a charset field in the request, we use it
if ($q->param('charset')) {
  $q->param('charset') =~ /^([^ ]*)/;
  $File->{Form_Charset} = lc $1;
}

#
# Figure out which charset was detected.
if    ($File->{HTTP_Charset}) {$File->{Charset} = $File->{HTTP_Charset}}
elsif ($File->{XML_Charset})  {$File->{Charset} = $File->{XML_Charset}}
elsif ($File->{META_Charset}) {$File->{Charset} = $File->{META_Charset}}
else  {                        $File->{Charset} = 'unknown'}

# Figure out which charset to use for validation.
$File->{Use_Charset} = $File->{Form_Charset} ?
            $File->{Form_Charset} : $File->{Charset};

#
# Setup SP environment for the charset.
if ($File->{Use_Charset} ne 'unknown') {
  $ENV{SP_CHARSET_FIXED} = 'YES';
  $ENV{SP_ENCODING}      = 'utf-8';
}

#
# Print header and jump links.
print $File->{Results}, &build_jump_links;


#
# Print different things if we got redirected or had a file upload.
if (URI::eq("$File->{URI}", $q->param('uri'))) { # @@ Why do we need to stringify here?
  &add_table("<a href='$uri_def_uri'>URI</a>",
      "<input type='text' name='uri' size='50' value='$File->{URI}' />");
} elsif ($q->param('uploaded_file')) {
  &add_table("File", $File->{URI});
} else {
  &add_table("<a href='$uri_def_uri'>URI</a>",
      '<a href="'. $q->param('uri'). '">'. $q->param('uri'). '</a>\n'.
      ' ' x 6 . '<span class="note">I was redirected to <a href="'.
      $File->{URI}. '">'. $File->{URI}. '</a></span>');
}

&add_table("Last Modified", $File->{Modified})  if $File->{Modified};
&add_table("Server", $File->{Server})  if $File->{Server};
&add_table("Content Length", $File->{Size})  if $File->{Size};
&add_table("Detected Character Encoding", "<code>$File->{Charset}</code>");
&add_table("Used Character Encoding", "<code>$File->{Use_Charset}</code>")
    unless $File->{Charset} eq $File->{Use_Charset};
&add_table("Select Character Encoding",
        $q->popup_menu(-name => 'charset',
                       -values => [
                                   "$File->{Charset} (as detected)",
                                   'utf-8 (Unicode, worldwide)',
                                   'iso-8859-1 (Western Europe)',
                                   'iso-8859-2 (Eastern Europe)',
                                   'iso-8859-5 (Cyrillic)',
                                   'iso-8859-7 (Greek)',
                                   'euc-jp (Japanese, Unix)',
                                   'shift_jis (Japanese, Win/Mac)',
                                   'iso-2022-jp (Japanese, email)',
                                   'euc-kr (Korean)',
                                   'GB2312 (Chinese, simplified)',
                                   'Big5 (Chinese, traditional)',
                                   # add more@@@@ '',
                                  ],
                       -default => $q->param('doctype'),
        ));

if ($File->{HTTP_Charset} ne $File->{META_Charset}
    and $File->{HTTP_Charset} ne ''
    and $File->{META_Charset} ne ''
    and $File->{Charset} ne 'unknown') {
  &add_warning(<<"EOHD");
      <strong>Character Encoding mismatch!</strong>
      The character encoding specified in the HTTP header
      (&#171;<code>$File->{HTTP_Charset}</code>&#187;) is different from the
      one specified in the META element
      (&#171;<code>$File->{META_Charset}</code>&#187;).
      I will use &#171;<code>$File->{Charset}</code>&#187; for this validation.
EOHD
} elsif ($File->{HTTP_Charset} ne $File->{XML_Charset}
    and $File->{HTTP_Charset} ne ''
    and $File->{XML_Charset} ne ''
    and $File->{Charset} ne 'unknown') {
  &add_warning(<<"EOHD");
      <strong>Character Encoding mismatch!</strong>
      The character encoding specified in the HTTP header
      (&#171;<code>$File->{HTTP_Charset}</code>&#187;) is different from the
      one specified in the XML declaration
      (&#171;<code>$File->{XML_Charset}</code>&#187;).
      I will use &#171;<code>$File->{Charset}</code>&#187; for this validation.
EOHD
}
if ($File->{Use_Charset} ne $File->{Charset}) {
  &add_warning(<<"EOHD");
      <strong>Character Encoding Override in effect!</strong>
      The detected character encoding
      (&#171;<code>$File->{Charset}</code>&#187;) has been supressed and the
      character encoding (&#171;<code>$File->{Use_Charset}</code>&#187;)
      used instead. The document will not be Valid until you alter the source
      file to reflect this new Character Encoding.
EOHD
  $File->{Tentative} = TRUE;
}

{  # block for character conversion and checking
  my @lines;
  unless ($File->{Use_Charset} eq 'utf-8' or $File->{Use_Charset} eq 'unknown') {
    my ($command, $result_charset) = split " ", $charsets->{$File->{Use_Charset}}, 2;
    if ($command eq 'I') {
      eval {my $c = Text::Iconv->new($result_charset, 'utf-8')};
      $command = '' if ($@);
    }
    elsif ($command eq 'X') {
      $@ = "$File->{Use_Charset} undefined; replace by $result_charset";
    }
    if ($command ne 'I') {
      &print_table;
      &print_warnings;
      &print_charset_error($@, $File->{Use_Charset});
      &clean_up_and_exit;
    }
    my $c = Text::Iconv->new($result_charset, 'utf-8');
    my $line = 0;
    for (@{$File->{Content}}) {
      my $in = $_;
      $line++;
      $_ = $c->convert($_); # $_ is local!!
      push @lines, $line if ($in ne "" and $_ eq "");
    }
  }
  # check correctness of UTF-8 both for UTF-8 input and for conversion results
  unless ($File->{Use_Charset} eq 'unknown') {
    for (my $i = 0; $i < $#{$File->{Content}}; $i++) {
      # substitution needed for very long lines (>32K),
      # to avoid backtrack stack overflow
      local $_ = $File->{Content}->[$i];
      s/  [\x00-\x7F]                           # ASCII
        | [\xC2-\xDF]        [\x80-\xBF]        # non-overlong 2-byte sequences
        |  \xE0[\xA0-\xBF]   [\x80-\xBF]        # excluding overlongs
        | [\xE1-\xEC\xEE\xEF][\x80-\xBF]{2}     # straight 3-byte sequences
        |  \xED[\x80-\x9F]   [\x80-\xBF]        # excluding surrogates
        |  \xF0[\x90-\xBF]   [\x80-\xBF]{2}     # planes 1-3
        | [\xF1-\xF3]        [\x80-\xBF]{3}     # planes 4-15
        |  \xF4[\x80-\x8F][\x80-\xBF]{2}        # plane 16
       //xg;
      push @lines, $i if length;
    }
  }
  if(@lines) {
    my $lines = $#lines ? "lines " : "line ";
    $lines .= join ", ", @lines;
    &print_table;
    &print_warnings;
    print <<"EOF";
    <p class="error">
      Sorry, I am unable to validate this document because on
      <strong>$lines</strong> it contained
      some byte(s) that I cannot interpret as
      <code>$File->{Use_Charset}</code>.
      Please check both the content of the file
      and the character encoding indication.
    </p>
EOF
    &clean_up_and_exit;
  }
}

my $xmlflags = '-wnon-sgml-char-ref';
my $catalog  = $sgmlstuff . '/catalog';

if ($File->{Type} eq 'xhtml') {
  $catalog               = $sgmlstuff . '/xhtml.soc';
  $ENV{SP_CHARSET_FIXED} = 'YES';
  $ENV{SP_ENCODING}      = 'UTF-8';
  $xmlflags              = '-wxml';
} elsif ($File->{Type} eq 'mathml') {
  $catalog               = $sgmlstuff . '/mathml.soc';
  $ENV{SP_CHARSET_FIXED} = 'NO';
  $ENV{SP_ENCODING}      = 'XML';
  $xmlflags              = '-wxml ';
  $sp = $osp; # *WARNING* *WARNING* Danger Will Robinson! :-)
} elsif ($File->{Type} eq 'xml' or $File->{Namespace}) {
  # no doctype, with xmlns attr on 1st element
  $File->{Type} = 'xml'; # @@ probably a better way to do this
  $catalog               = $sgmlstuff . '/sp-1.3/pubtext/xml.soc';
  $ENV{SP_CHARSET_FIXED} = 'YES';
  $ENV{SP_ENCODING}      = 'XML';
  $xmlflags              = '-wxml';
  $xmlflags             .= ' -wno-valid' unless $File->{DOCTYPE};
}

my $command  = "$sp -f$temp -E0 $xmlflags -c $catalog";

&add_table("nsgmls command line", "<code>$command</code>") if $DEBUG;

open CHECKER, "|$command - >$temp.esis"
  or &internal_error ("open(|$command - >$temp.esis) returned: $!");

for (@{$File->{Content}}) {print CHECKER $_, "\n"};
close CHECKER;

$File = &parse_errors($File, $temp); # Parse error output.

$File->{ESIS} = [];
my $elements_found = 0;
open ESIS, "$temp.esis" or &internal_error("open($temp.esis) returned: $!");
while (<ESIS>) {
  push @{$File->{'DEBUG'}->{ESIS}}, $_;
  $elements_found++ if /^\(/;

  if ($File->{Type} eq 'xml' or $File->{Type} eq 'xhtml') {
    if (/^Axmlns() \w+ (.*)/ or /^Axmlns:([^ ]+) \w+ (.*)/) {
      if (not $File->{Namespace} and $elements_found == 0 and $1 eq "") {
	$File->{Namespace} = $2;
      }
      $File->{Namespaces}->{$2}++;
    }
  }
  next if / IMPLIED$/;
  next if /^ASDAFORM CDATA /;
  next if /^ASDAPREF CDATA /;
  chomp; # Removes trailing newlines
  push @{$File->{ESIS}}, $_;
}
close ESIS              or warn "close($temp.esis) returned: $!";

my $fpi;
my $version = 'unknown';
if ($File->{Type} eq 'xhtml' or $File->{Type} eq 'mathml') {
  $fpi = $File->{DOCTYPE};
} elsif ($File->{Type} eq 'xml') {
  $fpi = 'XML';
} else {
  for (@{$File->{ESIS}}) {
    next unless /^AVERSION CDATA (.*)/;
    $fpi = $1;
    last;
  }
  # Needed for HTML4 Strict, which has no version attribute on the HTML element
  if (length $File->{DOCTYPE} and not defined $fpi) {$fpi = $File->{DOCTYPE}};
}
$version = $pub_ids->{$fpi} || 'unknown';

if ($File->{Type} eq 'xml' or $File->{Type} eq 'xhtml') {
  &add_table("Document Type", $version);
  if ($File->{Type} eq 'xhtml' and $File->{Namespace} ne 'http://www.w3.org/1999/xhtml') {
    &add_warning ("Unknown namespace (&#171;<code>$File->{Namespace}</code>&#187;) for text/html document!");
    if ($File->{Namespace} ne '') {
      &add_table("Root Namespace",
	"<a href='$File->{Namespace}'>$File->{Namespace}</a>");
    }
  } else {
    if ($File->{Namespace} ne '') {
      &add_table("Root Namespace",
	"<a href='$File->{Namespace}'>$File->{Namespace}</a>");
    }
  }

  if (scalar keys %{$File->{Namespaces}} > 1) {
    my $namespaces = "<ul>";
    for (keys %{$File->{Namespaces}}) {
      $namespaces .= "\t<li><a href='$_'>$_</a></li>\n"
          unless $_ eq $File->{Namespace}; # Don't repeat Root Namespace.
    }
    &add_table("Other Namespaces", $namespaces . "</ul>");
  }
} else {
  &add_table("Current Doctype", $version); # is this current or detected???
}
&add_table("Select Doctype",
        $q->popup_menu(-name => 'doctype',
                       -values => [
                                   '(specified inline)',
                                   'XHTML 1.0 Strict',
                                   'XHTML 1.0 Transitional',
                                   'XHTML 1.0 Frameset',
                                   'HTML 4.01 Strict',
                                   'HTML 4.01 Transitional',
                                   'HTML 4.01 Frameset',
                                   'HTML 3.2',
                                   'HTML 2.0',
                                  ],
                       -default => $q->param('doctype'),
        ));
&print_table;
&print_warnings;

if ($File->{Type} eq 'xml' or $File->{Type} eq 'xhtml' or $File->{Type} eq 'mathml') {
  my $xmlvalid = ($File->{DOCTYPE} ? ' and validity' : '');
  print <<"EOHD";
  <p>
    Below are the results of checking this document for <a
    href="http://www.w3.org/TR/REC-xml#sec-conformance">XML
    well-formedness</a>$xmlvalid.
  </p>

EOHD
} else {
  print <<"EOHD";
  <p>
    Below are the results of attempting to parse this document with
    an SGML parser.
  </p>
EOHD
}

if (defined $File->{Tentative}) {
  print <<".EOF.";
  <p class="Warning">
    Please note that you have chosen one or more options that alter the content
    of the document before Validation. Even if no errors are reported below,
    the document will not be Valid until you manually make the changes we have
    performed automatically. Specifically, since you used some of the options
    that Override a property of the document (e.g. the DOCTYPE or Character
    Encoding), you must make the same change to the source document before it
    can be valid.
  </p>
.EOF.
}

if (scalar @{$File->{Errors}}) {
  $q->param('ss', TRUE);
  &report_errors($File)
} else {
  &report_valid($File)
}

&weblint()          if $q->param('weblint');
&outline($File)     if $q->param('outline');
&show_source($File) if $q->param('ss');
&parse_tree($File)  if $q->param('sp');
&show_esis($File)   if $q->param('esis');
&show_errors($File) if $q->param('errors');

&clean_up_and_exit;


#############################################################################
# Subroutine definitions
#############################################################################

#
# Add info to the metadata table datastructure.
sub add_table {push @{$File->{Table}}, { Head => $_[0], Tail => $_[1]}};

#
# Print the table containing the metadata about the Document Entity.
sub print_table {
  my $tableEntry;
  add_table("Options",
      '         <input type="checkbox" value="" name="ss"' .
      ($q->param('ss')      ? 'checked="checked"' : '') . " />Show Source\n" .
      '         <input type="checkbox" value="" name="outline"' .
      ($q->param('outline') ? 'checked="checked"' : '') . " />Outline\n" .
      '         <input type="checkbox" value="" name="sp"' .
      ($q->param('sp')      ? 'checked="checked"' : '') . " />Parse Tree\n" .
      '         <input type="checkbox" value="" name="noatt"' .
      ($q->param('noatt')   ? 'checked="checked"' : '') . " />...no attributes\n"
    );
  print "  <form method='get' action='/check'><table class='header'>\n";
  for $tableEntry (@{$File->{Table}}) {
    print "    <tr>\n";
    print ' ' x 6, "<th>", $$tableEntry{Head}, ": </th>\n";
    print ' ' x 6, "<td>", $$tableEntry{Tail}, "</td>\n";
    print "    </tr>\n";
  }
  print "    <tr><th><input type='submit' value='Revalidate' /></th><td>&nbsp;</td>\n";
  print "  </table></form>\n";
}

#
# Add a waring message to the output.
sub add_warning {push @{$File->{Warnings}}, shift};

#
# Print out a list of warnings.
sub print_warnings {
  return unless defined @{$File->{Warnings}};
  print "  <div><h2>Warnings</h2>\n  <ul>\n";
  print qq(    <li>Warning: $_</li>\n) for @{$File->{Warnings}};
  print "  </ul></div>\n";
}

#
# Print HTML explaining why/how to use a DOCTYPE Declaration.
sub output_doctype_spiel {
  print <<"EOF";
    <p>
      You should make the first line of your HTML document a DOCTYPE
      declaration, for example, for a typical <a
      href="http://www.w3.org/TR/html4/">HTML 4.01</a> document:
    </p>

    <pre>
      &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;
      &lt;HTML&gt;
	&lt;HEAD&gt;
	  &lt;TITLE&gt;Title&lt;/TITLE&gt;
	&lt;/HEAD&gt;

	&lt;BODY&gt;
	  &lt;-- ... body of document ... --&gt;
	&lt;/BODY&gt;
      &lt;/HTML&gt;</pre>

EOF
}

#
# Spit out some closing HTML at the end of output.
sub output_closing {
  print <<"EOF";
<hr>

<address>
  <a href="${abs_svc_uri}check/referer"><img
     src="http://www.w3.org/Icons/valid-html401" height="31" width="88"
     align=right border="0" alt="Valid HTML 4.01!"></a>
  <a href="/feedback.html">Gerald Oskoboiny</a><br>
  Last modified: $DATE
</address>

</body>

</html>
EOF
}


#
# Leave a message and then die (use for internal errors only)
sub internal_error {
  my ($dieMessage) = shift;
  print <<"EOF";
    <hr>
    <strong class="error">Internal server error ($dieMessage).</strong>
    Please contact <a href="mailto:$MAINTAINER">maintainer</a>.
EOF
  &output_closing;
  &erase_stuff;
  die "$dieMessage\n";
}


#
# Delete temporary files.
sub erase_stuff {
  unlink $temp        or warn "unlink($temp) returned: $!\n";
  unlink "$temp.esis" or warn "unlink($temp.esis) returned: $!\n";
  unlink "$temp.weblint";
}


#
# Clean up and exit... :-)
sub clean_up_and_exit {
  &output_closing;
  &erase_stuff;
  exit;
}


#
# Redirect them to the home page. Simplistic error handling.
sub redirect_to_home_page {
  print <<".EOF.";
Status: 301 Moved Permanently
Content-Type: text/html
Location: $abs_svc_uri

<title>Moved!</title>
<p>Please see <a href="$abs_svc_uri">the home page.</a></p>
.EOF.
  &clean_up_and_exit;
}


#
# Generate HTML for the "Jump to:" links in results.
sub build_jump_links {

    my $text  = '';
    my $count = 0;

    $count++ if $q->param('ss');
    $count++ if $q->param('sp');
    $count++ if $q->param('weblint');
    $count++ if $q->param('outline');

    if ( $count ) {
	$text .= "  <p>\n    Jump to: ";
	if ( $q->param('weblint') ) {
	    $text .= "<a\n      href=\"#weblint\">Weblint Results</a>";
	    $count--;
	    $text .= " or " if ( $count == 1 );
	    $text .= ", "   if ( $count >  1 );
	}
	if ( $q->param('outline') ) {
	    $text .= "<a\n      href=\"#outline\">Outline</a>";
	    $count--;
	    $text .= " or " if ( $count == 1 );
	    $text .= ", "   if ( $count >  1 );
	}
	if ( $q->param('ss') ) {
	    $text .= "<a\n      href=\"#source\">Source Listing</a>";
	    $count--;
	    $text .= " or " if ( $count == 1 );
	    $text .= ", "   if ( $count >  1 );
	}
	if ( $q->param('sp') ) {
	    $text .= "<a\n      href=\"#parse\">Parse Tree</a>";
	}
	$text .= ".\n  </p>\n\n";
    }
    return $text;

}


#
# Proxy authentication requests.
sub authenticate {
  my $resource   = shift;
  my $authHeader = shift;

    print <<"EOF";
Status: 401 Authorization Required
WWW-Authenticate: $authHeader
Connection: close
Content-Type: text/html

<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">
<HTML><HEAD>
<TITLE>401 Authorization Required</TITLE>
</HEAD><BODY>
<H1>Authorization Required</H1>
<p>
  Sorry, I am not authorized to access the specified URI.
</p>

<p>
  The URI you specified,
</p>

<blockquote>
  <code><a href="$resource">$resource</a></code>
</blockquote>

<p>
  returned a 401 "authorization required" response when I tried
  to download it.
</p>

<p>
  You should have been prompted by your browser for a
  username/password pair; if you had supplied this information, I
  would have forwarded it to your server for authorization to
  access the resource. You can use your browser's "reload" function
  to try again, if you wish.
</p>

<p>
  Of course, you may not want to trust me with this information,
  which is fine. I can tell you that I don't log it or do
  anything else nasty with it, and you can <a
  href="${abs_svc_uri}source/">download the source for
  this service</a> to see what it does, but you have no guarantee
  that this is actually the code I'm using; you basically have to
  decide whether to trust me or not. :-)
</p>

<p>
  Note that you shouldn't use HTTP Basic Authentication for
  anything which really needs to be private, since the password
  goes across the network unencrypted.
</p>
EOF
}


#
# Complain about unknown HTTP responses.
sub print_unknown_http_error_message {
  my $uri = shift;
  my $code = shift;
  my $message = shift;

  print <<"EOF";
  <p>
    I got the following unexpected response when trying to
    retrieve <code><a href="$uri">$uri</a></code>:
  </p>

  <blockquote>
    <code>$code $message</code>
  </blockquote>

  <p>
    Please make sure you have entered the URI correctly.
  </p>

EOF
}


#
# Complain about strange charsets.
sub print_charset_error {
  my $error   = shift;
  my $charset = shift;

  print <<".EOF.";
  </ul>
  <p>Sorry!
    A fatal error occurred when attempting to transcode the character encoding
    of the document. Either we do not support this character encoding yet, or you 
    have specified a non-existent character encoding (often a misspelling).
  </p>
  <p>The detected character encoding was "$charset".</p>
  <p>The error was "$error".</p>
  <p>
    If you believe the character encoding to be valid you can submit a request for
    that character encoding (see the <a href="/feedback.html">feedback page</a>
    for details) and we will look into supporting it in the future.
  </p>
.EOF.
}


#
# Print blurb advocating using the CSS Validator.
sub output_css_validator_blurb {
  my $uri = shift;
  $uri = ent($uri);

  print <<"EOHD";
  <p>
    If you use <a href="http://www.w3.org/Style/CSS/">CSS</a> in your document,
    you should also <a
    href="http://jigsaw.w3.org/css-validator/validator?uri=$uri">check it for
    validity</a> using the W3C <a
    href="http://jigsaw.w3.org/css-validator/">CSS Validation Service</a>.
  </p>
EOHD
}


#
# Read TAB-delimited configuration files. Returns a hash reference.
sub read_cfg {
  my $file = shift;
  my %cfg;

  open CFG, $file or die "open($file) returned: $!\n";
  while (<CFG>) {
    next if /^\s*$/;
    next if /^\s*#/;
    chomp;
    my($k, $v) = split /\t+/, $_;
    $cfg{$k} = $v;
  }
  close CFG;
  return \%cfg;
}

#
# Fetch an URI and return the content and selected meta-info.
sub handle_uri {
  my $q    = shift; # The CGI object.
  my $File = shift; # The master datastructure.

  my $uri = $q->param('uri'); # The URI to fetch.

  my $ua = new LWP::UserAgent;
  $ua->agent("W3C_Validator/$VERSION " . $ua->agent);
  $ua->parse_head(0);  # Parse the http-equiv stuff ourselves. @@ Why?
  my $req = new HTTP::Request(GET => $uri);

  # If we got a Authorization header, the client is back at it after being
  # prompted for a password so we insert the header as is in the request.
  if($ENV{HTTP_AUTHORIZATION}){
    $req->headers->header(Authorization => $ENV{HTTP_AUTHORIZATION});
  }

  my $res = $ua->request($req);

  unless ($res->code == 200) {
    if ($res->code == 401) {
      &authenticate($res->request->url, $res->www_authenticate);
    } else {
      print $File->{Results};
      &print_unknown_http_error_message($uri, $res->code, $res->message);
    }
    &clean_up_and_exit;
  }

  my($type, $charset) = &parse_content_type($res->header('Content-Type'));

  my $lastmod = undef;
  if ( $res->last_modified ) {
    $lastmod = scalar(gmtime($res->last_modified));
  }

  $File->{Content}      = &normalize_newlines($res->content);
  $File->{Type}         = $type;
  $File->{HTTP_Charset} = $charset;
  $File->{Modified}     = $lastmod;
  $File->{Server}       = scalar($res->server);
  $File->{Size}         = scalar($res->content_length);
  $File->{URI}          = scalar($res->request->url);

  return $File;

}

#
# Handle uploaded file and return the content and selected meta-info.
sub handle_file {
  my $q    = shift; # The CGI object.
  my $File = shift; # The master datastructure.

  my $f = $q->param('uploaded_file');
  my $h = $q->uploadInfo($f);
  my $file;

  while (not eof $f) {$file .= <$f>};
  my($type, $charset) = &parse_content_type($h->{'Content-Type'});

  $File->{Content}      = &normalize_newlines($file);
  $File->{Type}         = $type;
  $File->{HTTP_Charset} = $charset;
  $File->{Modified}     = $h->{'Last-Modified'};
  $File->{Server}       = $h->{'Server'};
  $File->{Size}         = $h->{'Content-Length'};
  $File->{URI}          = $q->param('uploaded_file');

  return $File;
}

#
# Handle uploaded file and return the content and selected meta-info.
sub handle_frag {
  my $q    = shift; # The CGI object.
  my $File = shift; # The master datastructure.

  $File->{Content}      = &normalize_newlines(shift->param('fragment'));
  $File->{Type}         = 'html';
  $File->{HTTP_Charset} = '';
  $File->{Modified}     = '';
  $File->{Server}       = '';
  $File->{Size}         = '';
  $File->{URI}          = 'upload://Form Submission';

  return $File;
}


#
# Parse a Content-Type and parameters. Return document type and charset.
sub parse_content_type {
  my $Content_Type = shift;
  my $charset      = '';
  my $type         = '';

  my($ct, @param) = split /\s*;\s*/, lc $Content_Type;

  $type = $file_type->{$ct} || $ct;

  foreach my $param (@param) {
    my($p, $v) = split /\s*=\s*/, $param;
    next unless $p =~ m(charset)i;
    if ($v =~ m/([\'\"]?)(\S+)\1/i) {
      $charset = lc $2;
      last;
    }
  }

  return $type, $charset;
}


#
# Normalize newline forms (CRLF/CR/LF) to native newline.
sub normalize_newlines {
  my $file = shift;

  $file =~ s(\015\012?|\012){\n}g; # Turn ASCII CRLF into native newline.

  return [split /\n/, $file];
}


#
# Return $_[0] encoded for HTML entities (cribbed from merlyn).
sub ent {
  local $_ = shift;
  s(["<&>"]){'&#' . ord($&) . ';'}ge;
  return $_;
}


#
# Truncate source lines for report.
sub truncate_line {
  my $line = shift;
  my $col  = shift;

  if (length $line > 70) {
    if ($col < 25) {      # Truncate at 70 chars and right side only.
      $line = substr($line, 0, 70) . " ...";
    } elsif ($col > 70) { # Keep rightmost 70 chars; left side only.
      my $diff = $col - 50;
      $line = "... " . substr($line, $diff, 70);
      if (length $line == 70 + 4) {
	$line .= " ...";
      }
      if ($col > $diff) {
	$col -= $diff;
      } else {
	$col -= 70;
      }
    } else { # Truncate both sides; leave more on left, and 30 chars on right.
      if ($col < 35) {
	$line = "... " . substr($line, 0, 60);
      } else {
	$line = "... " . substr($line, $col - 35, 60);
	$col = 35;
      }
      if (length $line == 60 + 4) {$line .= " ..."};
    }
  }

  return $line, $col;
}


#
# Supress any existing DOCTYPE by commenting it out.
sub supress_doctype {
  no strict 'vars';
  my $file = shift;
  local $HTML = '';

  HTML::Parser->new(default_h     => [sub {$HTML .= shift}, 'text'],
		    declaration_h => [sub {$HTML .= '<!-- ' . $_[0] . ' -->'}, 'text']
		   )->parse(join "\n", @{$file});
  return [split /\n/, $HTML];
}


#
# Parse errors reported by SP.
sub parse_errors ($$) {
  my $File = shift;
  my $file = shift;

  $File->{Errors} = []; # Initialize to an (empty) anonymous array ref.

  open ERRORS, "<$file" or &internal_error("open($file) returned: $!");
  for (<ERRORS>) {
    push @{$File->{'DEBUG'}->{Errors}}, $_;
    my($err, @errors);
    next if /^<OSFD>0:[0-9]+:[0-9]+:[^A-Z]/;
    next if /numbers exceeding 65535 not supported/;
    next if /URL Redirected to/;

    my(@_err) = split /:/;
    if ($_err[1] =~ m(^<URL>)) {
      @errors = ($_err[0], join(':', $_err[1], $_err[2]), @_err[3..$#_err]);
    } else {
      @errors = @_err;
    }
    $err->{src}  = $errors[1];
    $err->{line} = $errors[2];
    $err->{char} = $errors[3];
    $err->{type} = $errors[4];
    if ($err->{type} eq 'W' or $err->{type} eq 'E') {
      $err->{msg}  = $errors[5];
    } else {
      $err->{type} = 'I';
      $err->{msg}  = $errors[4];
    }
    push @{$File->{Errors}}, $err;
  }
  close ERRORS          or &internal_error("close($file) returned: $!\n");

  return $File;
}


#
# Generate a HTML report of detected errors.
sub report_errors ($) {
  my $File = shift;
  foreach my $err (@{$File->{Errors}}) {

    # An unknown FPI and no SI.
    if (   $err->{msg} =~ m(cannot generate system identifier for entity)
	or $err->{msg} =~ m(unrecognized ({{)?DOCTYPE(}})?)i
        or $err->{msg} =~ m(no document type declaration)i) {
      print <<"    .EOF.";
    <p><strong>Fatal Error</strong>: $err->{msg}</p>
    <p>
      I could not parse this document, because it uses a public identifier that
      is not in my <a href="/sgml-lib/catalog">catalog</a>.
    </p>
    .EOF.
      &output_doctype_spiel;
      last;
    }

    # No or unknown FPI and a relative SI.
    if ($err->{msg} =~ m(cannot (open|find))) {
      print <<"    .EOF.";
    <p><strong>Fatal Error: $err->{msg}</p>
    <p>
      I could not parse this document, because it makes reference to a
      system-specific file instead of using a well-known public identifier to
      specify the type of markup being used.
    </p>
    .EOF.
      &output_doctype_spiel;
      last;
    }


    my($line, $col) = &truncate_line($File->{Content}->[$err->{line}-1], $err->{char});

    # Strip curlies from lq-nsgmls output.
    $err->{msg} =~ s/[{}]//g;

    # Find index into the %frag hash for the "explanation..." links.
    $err->{idx} =  $err->{msg};
    $err->{idx} =~ s/"[^\"]+"/FOO/g;
    $err->{idx} =~ s/[^A-Za-z ]//g;

    $line = &ent($line); # Entity encode.
    $line =~ s/\t/ /g;   # Collapse TABs.

    print qq(  <li>Line <a href="#line-$err->{line}">$err->{line}</a>, column $col:\n);

    print "<pre>  <code class=input>$line</code>\n";
    print " " x ($col + 2); # 2 is the number of spaces before <code> above
    print " " x 4 if $col != $err->{char}; # only for truncated lines
    print "<span class=markup>^</span></pre>\n<p>\n";

    print qq{<span class="error">Error: $err->{msg}</span>};

    if (defined $frag->{$err->{idx}}) {
      print qq{ (<a href="$faqerrloc#$frag->{$err->{idx}}">explanation...</a>)};
    }

    print "</p>\n";

  }
  print "</ul>\n";
  print "<hr>\n";
  if ($version eq 'unknown') {
    print "<p>Sorry, I can't validate this document.</p>";
  } elsif ($File->{Type} eq 'xml') {
    print "<p>Sorry, this document is not well-formed XML.</p>";
  } else {
    print "<p>Sorry, this document does not validate as $version.</p>";
    &output_css_validator_blurb($q->param('uri'));
  }
}


#
# Output "This page is Valid" report.
sub report_valid {
  my $File = shift;
  my $gifborder   = ' border="0"';
  my $xhtmlendtag = '';
  my($image_uri, $alttext, $gifhw);

  if ($File->{Type} eq 'xml' or $File->{Type} eq 'xhtml') {
    print "\n  <pre>\n    No errors found! ";
    print "<a href=\"#sp-lim\">*</a></pre>\n\n";
  } else {
    print "\n  <pre>\n    No errors found!</pre>\n\n";
  }

  unless ($version eq 'unknown' or defined $File->{Tentative}) {
    if ($version =~ /^HTML 2\.0$/) {
      $image_uri = "${abs_svc_uri}images/vh20";
      $alttext = "Valid HTML 2.0!";
      $gifborder = "";
    } elsif ($version =~ /HTML 3\.2</) {
      $image_uri = "http://www.w3.org/Icons/valid-html32";
      $alttext = "Valid HTML 3.2!";
      $gifhw   = ' height="31" width="88"';
    } elsif ($version =~ /HTML 4\.0<\/a> Strict$/) {
      $image_uri = "http://www.w3.org/Icons/valid-html40";
      $alttext = "Valid HTML 4.0!";
      $gifborder = "";
      $gifhw   = ' height="31" width="88"';
    } elsif ($version =~ /HTML 4\.0<\/a> /) {
      $image_uri = "http://www.w3.org/Icons/valid-html40";
      $alttext = "Valid HTML 4.0!";
      $gifhw   = ' height="31" width="88"';
    } elsif ($version =~ /HTML 4\.01<\/a> Strict$/) {
      $image_uri = "${abs_svc_uri}images/vh401";
      $alttext = "Valid HTML 4.01!";
      $gifborder = "";
      $gifhw   = ' height="31" width="88"';
    } elsif ($version =~ /HTML 4\.01<\/a> /) {
      $image_uri = "${abs_svc_uri}images/vh401";
      $alttext = "Valid HTML 4.01!";
      $gifhw   = ' height="31" width="88"';
    } elsif ($version =~ /XHTML 1\.0<\/a> /) {
      $image_uri = "http://www.w3.org/Icons/valid-xhtml10";
      $alttext = "Valid XHTML 1.0!";
      $gifborder = "";
      $gifhw   = ' height="31" width="88"';
      $xhtmlendtag = " /";
    } elsif ($version =~ /XHTML Basic 1.0/) {
      $image_uri = "${abs_svc_uri}/images/vxhtml-basic10";
      $alttext = "Valid XHTML Basic 1.0!";
      $gifborder = "";
      $gifhw   = ' height="31" width="88"';
      $xhtmlendtag = " /";
    } elsif ($version =~ /XHTML 1.1/) {
      $image_uri = "${abs_svc_uri}/images/vxhtml11";
      $alttext = "Valid XHTML 1.1!";
      $gifborder = "";
      $gifhw   = ' height="31" width="88"';
      $xhtmlendtag = " /";
    } elsif ($version =~ /HTML 3\.0/) {
      $image_uri = "${abs_svc_uri}images/vh30";
      $alttext = "Valid HTML 3.0!";
    } elsif ($version =~ /Netscape/) {
      $image_uri = "${abs_svc_uri}images/vhns";
      $alttext = "Valid Netscape-HTML!";
    } elsif ($version =~ /Hotjava/) {
      $image_uri = "${abs_svc_uri}images/vhhj";
      $alttext = "Valid Hotjava-HTML!";
    }

    if (defined $image_uri) {
      print <<"EOHD";
  <p>
    <img src="$image_uri" alt="$alttext"> Congratulations, this
    document validates as $version!
  </p>

  <p>
    To show your readers that you have taken the care to create an
    interoperable Web page, you may display this icon on any page
    that validates. Here is the HTML you could use to add this icon
    to your Web page:
  </p>
  <pre>
  &lt;p&gt;
    &lt;a href="${abs_svc_uri}check/referer"&gt;&lt;img$gifborder
        src="$image_uri"
        alt="$alttext"$gifhw$xhtmlendtag&gt;&lt;/a&gt;
  &lt;/p&gt;</pre>
  <p>
    If you like, you can download a copy of this image (in <a
    href="${image_uri}.png">PNG</a> or <a href="${image_uri}.gif">GIF</a>
    format) to keep in your local web directory, and change the HTML fragment
    above to reference your local image rather than the one on this server.
  </p>

EOHD
    }
  }
  if ($File->{Type} eq 'xml' and not $File->{DOCTYPE}) {
    print "  <p>Congratulations, this document is well-formed XML.</p>\n";
  } elsif (defined $File->{Tentative}) {
    print "  <p>\n    This document would validate as the document type specified if you updated it to match the Options used.\n  </p>\n";
  } elsif ($version eq 'unknown' or not defined $image_uri) {
    print "  <p>\n    Congratulations, this document validates as the document type specified! (I don't have an icon for this one yet, sorry.)\n  </p>\n";
  }

  unless ($q->param('uploaded_file')) {
    my $thispage = $q->url(-query => 0);
    $thispage .= qq(?uri=$File->{URI});
    $thispage .= ';ss=1'      if $q->param('ss');
    $thispage .= ';sp=1'      if $q->param('sp');
    $thispage .= ';noatt=1'   if $q->param('noatt');
    $thispage .= ';outline=1' if $q->param('outline');

    &output_css_validator_blurb($q->param('uri'));

    print <<"EOHD";
  <p>
    If you would like to create a link to <em>this</em> page (i.e., this
    validation result) to make it easier to re-validate this page in the
    future or to allow others to validate your page, the URI is:
  </p>

  <blockquote>
    <code><a href="$thispage">$thispage</a></code>
  </blockquote>

  <p>
    (Or, you can just add the current page to your bookmarks or hotlist.)
  </p>
EOHD
  }
  if ($File->{Type} eq 'xml' or $File->{Type} eq 'xhtml') {
    print qq{    <h2><a name="sp-lim">Caveat</a></h2>
      <p>
	This validator is based on SP, which has <a
	href="http://www.jclark.com/sp/xml.htm">some limitations
	in its support for XML</a>.
      </p>
	    };
  }
}


#
# Legacy support. Print blurb to clarify status of weblint support.
sub weblint {
  print <<"EOF";
  <div class="mtb">
    <hr>
    <h2><a name="weblint">Weblint Doesnt Live Here Any More</a></h2>
    <p>
      <a href="http://www.weblint.org/">Weblint</a> is no longer beeing
      maintained and has become badly out of date with the current state
      of the web, and so this feature has been deprecated.
    </p>
    <p>
      If you want to get the Weblint results you can use one of the web
      frontends referenced from the
      <a href="http://www.weblint.org/">Weblint</a> home page or install
      a copy of it locally.
    </p>
    <p>
      We are currently investigating alternative methods to replace the
      Weblint feature in the Validator.
      <a href="http://www.w3.org/People/Raggett/tidy/">Tidy</a> appears
      to be a likely candidate at this point.
    </p>
  </div>
EOF
}


#
# Produce an outline of the document based on Hn elements from the ESIS.
sub outline {
  my $File = shift;

  print <<'EOF';
  <div id="outline" class="mtb">
    <hr>
    <h2><a name="outline">Outline</a></h2>
    <p>
      Below is an outline for this document, automatically generated from the
      heading tags (<code>&lt;H1&gt;</code> through <code>&lt;H6&gt;</code>.)
    </p>
EOF

  my $prevlevel = 0;
  my $indent    = 0;
  my $level     = 0;

  for (1 .. $#{$File->{ESIS}}) {
    my $line = $File->{ESIS}->[$_];
    next unless $line =~ /^\(H([1-6])$/i;
    $prevlevel = $level;
    $level     = $1;

    print "    </ul>\n" x ($prevlevel - $level); # perl is so cool.
    if ($level - $prevlevel == 1) {print "    <ul>\n"};
    foreach my $i (($prevlevel + 1) .. ($level - 1)) {
      print qq(  <ul>\n    <li class="warning">A level $i heading is missing!\n);
    }
    if ($level - $prevlevel > 1) {print "    <ul>\n"};

    $line       = '';
    my $heading = '';
    until (substr($line, 0, 3) =~ /^\)H$level/i) {
      $line = $File->{ESIS}->[$_++];
      $line =~ s/\\011/ /g;
      $line =~ s/\\012/ /g;
      if ($line =~ /^-/) {
	my $headcont = $line;
	substr($headcont, 0, 1) = " ";
	$headcont =~ s/\\n/ /g;
	$heading .= $headcont;
      } elsif ($line =~ /^AALT CDATA( .+)/i) {
	my $headcont = $1;
	$headcont =~ s/\\n/ /g;
	$heading .= $headcont;
      }
    }

    $heading = substr($heading, 1); # chop the leading '-' or ' '.
    $heading = &ent($heading);
    print "    <li>$heading\n";
  }
  print "    </ul>\n" x $level;
  print <<'EOF';
    <p>
      If this does not look like a real outline, it is likely that the
      heading tags are not being used properly. (Headings should reflect
      the logical structure of the document; they should not be used simply
      to add emphasis, or to change the font size.)
    </p>
    </div>
EOF
}


#
# Create a HTML representation of the document.
sub show_source {
  my $File = shift;
  my $line = 1;

  print <<'EOF';
  <div id="source" class="mtb">
    <hr>
    <h2><a name="source">Source Listing</a></h2>

    <p>Below is the source input I used for this validation:</p>
    <pre>
EOF

  for (@{$File->{Content}}) {
    printf "<a name=\"line-%s\">%4d</a>: %s\n", $line, $line, ent $_;
    $line++;
  }
  print "    </pre>\n  </div>";
}


#
# Create a HTML Parse Tree of the document for validation report.
sub parse_tree {
  my $File = shift;

  print <<'EOF';
  <div id="parse" class="mtb">
    <hr>
    <h2><a name="parse">Parse Tree</a></h2>
EOF
  if ($q->param('noatt')) {
    print <<'EOF';
    <p class="note">
      I am excluding the attributes, as you requested.
    </p>
EOF
  } else {
    print <<'EOF';
    <p class="note">
      You can also view this parse tree without attributes by selecting the
      appropriate option on <a href="./#byURI">the form</a>.
    </p>
EOF
  }

  my $indent   = 0;
  my $prevdata = '';

  print "<pre>\n";
  foreach my $line (@{$File->{ESIS}}) {
    if ($q->param('noatt')) {	# don't show attributes
      next if $line =~ /^A/;
      next if $line =~ /^\(A$/;
      next if $line =~ /^\)A$/;
    }

    $line =~ s/\\n/ /g;
    $line =~ s/\\011/ /g;
    $line =~ s/\\012/ /g;
    $line =~ s/\s+/ /g;
    next if $line =~ /^-\s*$/;

    if ($line =~ /^-/) {
      substr($line, 0, 1) = ' ';
      $prevdata .= $line;
      next;
    } elsif ($prevdata) {
      $prevdata = &ent($prevdata);
      $prevdata =~ s/\s+/ /go;
      print wrap(' ' x $indent, ' ' x $indent, $prevdata), "\n";
      undef $prevdata;
    }

    $line = &ent($line);
    if ($line =~ /^\)/) {
      $indent -= 2;
    }

    my $printme;
    chomp($printme = $line);
    $printme =~ s{^([()])(.*)}	# reformat and add links on HTML elements
		 { my $close = '';
		      $close = "/" if $1 eq ")";	# ")" -> close-tag
		   "&lt;" . $close . "<a href=\"" .
		   $element_ref . $element_uri->{lc($2)} .
		   "\">$2<\/a>&gt;"
		 }egx;
    $printme =~ s,^A,  A,;	# indent attributes a bit
    print ' ' x $indent, $printme, "\n";
    if ($line =~ /^\(/) {
      $indent += 2;
    }
  }
  print "</pre>\n";
  print "</div>\n";
}


#
# Do an initial parse of the Document Entity to extract charset and FPI.
sub preparse {
  my $File = shift;

  my $dtd = sub {
    return if $File->{Root};
    ($File->{Root}, $File->{DOCTYPE}) = shift =~  m(<!DOCTYPE\s+(\w+)\s+PUBLIC\s+(?:[\'\"])([^\"\']+)(?:[\"\']).*>)si;
  };
  my $pi = sub {
    my $pi = shift;
    $pi =~ m(<\?xml[^>]*\sencoding\s*=\s*([\"\'])([A-Za-z][A-Za-z0-9._\-]*)\1)s;
    $File->{XML_Charset} = lc $2;
  };
  my $start = sub {
    my $tag  = shift;
    my $attr = shift;
    my %attr = map {lc($_) => $attr->{$_}} keys %{$attr};

    if ($File->{Root}) {
      if (lc $tag eq 'meta') {
	if (lc $attr{'http-equiv'} eq 'content-type') {
	  $attr{content} =~ m(charset\s*=[\s\"\']*([^\s;\"\'>]*))si;
	  $File->{META_Charset} = lc $1;
	}
      }
      return unless $tag eq $File->{Root};
    } else {
      $File->{Root} = $tag;
    }
    if ($attr->{xmlns}) {$File->{Namespace} = $attr->{xmlns}};
  };

  my $p =  HTML::Parser->new(api_version => 3);
  $p->xml_mode(TRUE);
  $p->ignore_elements('BODY');
  $p->ignore_elements('body');
  $p->handler(declaration => $dtd, 'text');
  $p->handler(process => $pi, 'text');
  $p->handler(start => $start, 'tag,attr');
  $p->parse(join "\n", @{$File->{Content}});

  return $File;
}

#
# Print out the raw ESIS output for debugging.
sub show_esis ($) {
  print <<'EOF';
  <div id="raw_esis" class="mtb">
    <hr>
    <h2><a name="raw_esis">Raw ESIS Output</a></h2>
    <pre>
EOF
  for (@{shift->{'DEBUG'}->{ESIS}}) {
    s/\\012//g;
    s/\\n/\n/g;
    print ent $_;
  }
  print "    </pre>\n  </div>";
}

#
# Print out the raw error output for debugging.
sub show_errors ($) {
  print <<'EOF';
  <div id="raw_errors" class="mtb">
    <hr>
    <h2><a name="raw_errors">Raw Error Output</a></h2>
    <pre>
EOF
  for (@{shift->{'DEBUG'}->{Errors}}) {print ent $_};
  print "    </pre>\n  </div>";
}
