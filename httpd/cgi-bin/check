#!/usr/local/bin/perl
#
# W3C HTML Validation Service
# A CGI script to retrieve and validate an HTML file
#
# Copyright 1995-1999 Gerald Oskoboiny <gerald@w3.org>
#
# This source code is available under the license at:
#     http://www.w3.org/Consortium/Legal/copyright-software
#
# $Id: check,v 1.29 1999-09-05 23:22:28 gerald Exp $

use LWP::UserAgent;

#############################################################################
# Constant definitions
#############################################################################

$cvsrevision	= '$Revision: 1.29 $';
$cvsdate	= '$Date: 1999-09-05 23:22:28 $';

$logfile	= "/var/log/httpd/val-svc";

$uri_def_uri	= "http://www.w3.org/Addressing/#terms";
$faqloc		= "http://www.cs.duke.edu/~dsb/kgv-faq/";
$faqerrloc	= "${faqloc}errors.html";
$abs_svc_uri	= "http://validator.w3.org/";
$rel_img_uri	= "/images/";
$abs_img_uri	= "${abs_svc_uri}images/";

$sgmlstuff	= "/usr/local/src/validator/htdocs/sgml-lib";
$sp		= "/usr/local/bin/nsgmls";
$nkf		= "/usr/local/bin/nkf";

$sgmldecl	= "$sgmlstuff/REC-html40-19980424/HTML4.decl";
$xhtmldecl	= "$sgmlstuff/PR-xhtml1-19990824/xhtml1.dcl";
$xmldecl	= "/usr/local/src/validator/htdocs/sgml-lib/sp-1.3/pubtext/xml.dcl";

$revision	= $cvsrevision;
$revision	=~ s/^\$Revision: //;
$revision	=~ s/ \$$//;

# $notice		= "<p><strong>Note: This service will be intermittently unavailable for the next few hours for an operating system upgrade.</strong>";

umask( 022 );
$weblint	 = "/usr/bin/weblint";
$html2_doctype	 = qq{<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">};
$html32_doctype	 = qq{<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">};
$nice_html40_doctype	 = qq{<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN\n            "http://www.w3.org/TR/REC-html40/strict.dtd">};
$nice_html40t_doctype = qq{<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"\n            "http://www.w3.org/TR/REC-html40/loose.dtd">};
$nice_html40f_doctype = qq{<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN"\n            "http://www.w3.org/TR/REC-html40/frameset.dtd">};
$html40_doctype	 = qq{<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN "http://www.w3.org/TR/REC-html40/strict.dtd">};
$html40t_doctype = qq{<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">};
$html40f_doctype = qq{<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN" "http://www.w3.org/TR/REC-html40/frameset.dtd">};
$xhtmlt_doctype = qq{<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"};
$temp		 = "/tmp/validate.$$";
$lt		 = "\020";
$gt		 = "\021";
# $leftarrow	 = qq{${lt}tt${gt}${lt}img src="/images/arrow_left.gif" alt="^"${gt}${lt}/tt${gt}};
$leftarrow	 = "${lt}tt${gt}${lt}img src=\"/images/arrow_left.gif\" alt=\"^\"${gt}${lt}/tt${gt}";
$rightarrow	 = "${lt}tt${gt}${lt}img src=\"/images/arrow_right.gif\" alt=\"^\"${gt}${lt}/tt${gt}";
$contchars	 = "${lt}tt${gt}${lt}img src=\"/images/ellipsis.gif\" alt=\"[...]\"${gt}${lt}/tt${gt}";
$gifborder       = " border=0";

@options = ( 'weblint', 'pw', 'outline', 'ss', 'sp', 'noatt' );
# this doesn't work for some reason
# qw{
#     weblint pw outline ss sp noatt
# };

#############################################################################
# Array of FPIs -> plain text version strings
#############################################################################

%pub_ids = (
    '-//IETF//DTD HTML Level 0//EN//2.0', 'HTML 0.0',
    '-//IETF//DTD HTML Strict Level 0//EN//2.0', 'Strict HTML 0.0',

    '-//IETF//DTD HTML 2.0 Level 1//EN', 'HTML 1.0',
    '-//IETF//DTD HTML 2.0 Strict Level 1//EN', 'Strict HTML 1.0',

    '-//IETF//DTD HTML 2.0 Strict//EN', 'Strict HTML 2.0',
    '-//IETF//DTD HTML 2.0//EN', 'HTML 2.0',
    '-//IETF//DTD HTML 2.1E//EN', 'HTML 2.1E',

  '-//AS//DTD HTML 3.0 asWedit + extensions//EN', 'HTML 3.0 (AdvaSoft version)',
    '-//IETF//DTD HTML 3.0//EN', 'HTML 3.0 (Beta)',
    '-//W3O//DTD W3 HTML Strict 3.0//EN//', 'Strict HTML 3.0 (Beta)',

    '-//Sun Microsystems Corp.//DTD HotJava HTML//EN', 'Hotjava-HTML',
'-//Sun Microsystems Corp.//DTD HotJava Strict HTML//EN', 'Strict Hotjava-HTML',
    '-//WebTechs//DTD Mozilla HTML 2.0//EN', 'Netscape-HTML',
    '-//Netscape Comm. Corp. Strict//DTD HTML//EN', 'Strict Netscape-HTML',
    '-//Microsoft//DTD Internet Explorer 2.0 HTML//EN', 'MSIE-HTML',
    '-//Microsoft//DTD Internet Explorer 2.0 HTML Strict//EN', 'Strict MSIE-HTML',
    '-//Microsoft//DTD Internet Explorer 3.0 HTML//EN', 'MSIE 3.0 HTML',
    '-//Microsoft//DTD Internet Explorer 3.0 HTML Strict//EN', 'Strict MSIE 3.0 HTML',
    '-//OReilly and Associates//DTD HTML Extended 1.0//EN', 'O\'Reilly HTML Extended v1.0',
    '-//OReilly and Associates//DTD HTML Extended Relaxed 1.0//EN', 'O\'Reilly HTML Extended Relaxed v1.0',

    '-//IETF//DTD HTML V2.2//EN', 'HTML 2.2',
    '-//W3C//DTD HTML 1996-01//EN', 'HTML 1996-01',
    '-//W3C//DTD HTML 3.2 Final//EN', '<a href="http://www.w3.org/TR/REC-html32">HTML 3.2</a>',
    '-//W3C//DTD HTML Experimental 970421//EN', '<a href="http://www.w3.org/TR/NOTE-html-970421.html">HTML 3.2 + Style</a>',
    '+//Silmaril//DTD HTML Pro v0r11 19970101//EN', '<a href="http://www.ucc.ie/doc/www/html/dtds/htmlpro.html">HTML Pro</a>',
    '-//Spyglass//DTD HTML 2.0 Extended//EN', 'Spyglass HTML 2.0 Extended',
    'http://www.w3.org/MarkUp/Cougar/Cougar.dtd', '<a href="http://www.w3.org/MarkUp/Cougar/">HTML Level "Cougar"</a>',
    '-//W3C//DTD HTML 4.0//EN', '<a href="http://www.w3.org/TR/REC-html40/">HTML 4.0</a> Strict',
    '-//W3C//DTD HTML 4.0 Transitional//EN', '<a href="http://www.w3.org/TR/REC-html40/">HTML 4.0</a> Transitional',
    '-//W3C//DTD HTML 4.0 Frameset//EN', '<a href="http://www.w3.org/TR/PR-html40/">HTML 4.0</a> Frameset',
    '-//W3C//DTD HTML 4.01//EN', '<a href="http://www.w3.org/TR/1999/PR-html40-19990824/">HTML 4.01</a> Strict',
    '-//W3C//DTD HTML 4.01 Transitional//EN', '<a href="http://www.w3.org/TR/1999/PR-html40-19990824/">HTML 4.01</a> Transitional',
    '-//W3C//DTD HTML 4.01 Frameset//EN', '<a href="http://www.w3.org/TR/1999/PR-html40-19990824/">HTML 4.01</a> Frameset',
    '-//W3C//DTD XHTML 1.0 Strict//EN', '<a href="http://www.w3.org/TR/1999/PR-xhtml1-19990824/">XHTML 1.0</a> Strict',
    '-//W3C//DTD XHTML 1.0 Transitional//EN', '<a href="http://www.w3.org/TR/1999/PR-xhtml1-19990824/">XHTML 1.0</a> Transitional',
    '-//W3C//DTD XHTML 1.0 Frameset//EN', '<a href="http://www.w3.org/TR/1999/PR-xhtml1-19990824/">XHTML 1.0</a> Frameset',
    'XML', '<a href="http://www.w3.org/TR/REC-xml">XML</a>'

);

#############################################################################
# Array of errors -> fragment identifiers for error explanation links
#############################################################################

%frag = (
    'entity end not allowed in comment', 'unterm-comment-1',
    'name start character invalid only s and comment allowed in comment declaration', 'unterm-comment-2',
    'name character invalid only s and comment allowed in comment declaration', 'unterm-comment-2',
    'unknown declaration type FOO', 'bad-comment',
    'character FOO not allowed in attribute specification list', 'attr-char',
    'an attribute value must be a literal unless it contains only name characters', 'attr-quoted',
    'syntax of attribute value does not conform to declared value', 'bad-attr-char',
    'length of attribute value must not exceed LITLEN less NORMSEP', 'name-length',
    'element FOO undefined', 'undef-tag',
    'element FOO not allowed here', 'not-allowed',
    'there is no attribute FOO', 'undef-attr',
    'FOO is not a member of the group specified in the declared value of this attribute', 'undef-attr-val',
    'FOO is not a member of a group specified for any attribute', 'bad-abbrev-attr',
    'end tag for FOO omitted but its declaration does not permit this', 'no-end-tag',
    'end tag for element FOO which is not open', 'floating-close',
    'end tag for FOO which is not finished', 'omitted-content',
    'start tag for FOO omitted but its declaration does not permit this', 'no-start-tag',
    'general entity FOO not defined and no default entity', 'bad-entity',
    'non SGML character number', 'bad-char',
    'cannot generate system identifier for entity FOO', 'bad-pub-id'

#    'error', 'frag',
#    'character data is not allowed here', 'frag',

);

#############################################################################
# Set up some signal handlers in case we get killed (darned impatient people...)
#############################################################################

$SIG{'TERM'} = 'erase_stuff';
$SIG{'KILL'} = 'erase_stuff';
$SIG{'PIPE'} = 'IGNORE';
# $SIG{'CHLD'} = 'erase_stuff';

#############################################################################
# Process CGI variables
#############################################################################

# accept either check/foo or check?foo
$parameters = $ENV{PATH_INFO} || $ENV{QUERY_STRING};

if ( ! $parameters ) {
    &redirect_to_home_page;
}

foreach $pair (split(/[&;,]/, $parameters)) {

    # this referer handling probably needs fixing to handle strange cases
    # (possibly tied to the explanation given when connections fail;
    # the referer could be on an intranet, etc.)

    if ( $pair eq "/referer" && $ENV{HTTP_REFERER} =~ m,^http://, ) {
	$FORM{uri} = $ENV{HTTP_REFERER};
	next;
    }

    ($name, $value) = split(/=/, $pair);
    $value =~ tr/+/ /;
    $value =~ s/%([a-fA-F0-9][a-fA-F0-9])/pack("C", hex($1))/eg;

    $FORM{$name} = $value || "true";
}

# accept "url=foo" for backwards compatibility (but uri=foo is preferred)
$uri = URI::URL->new($FORM{uri} || $FORM{url});

if ( ( $uri eq "true" || length( $uri ) == 0 ) &&
        ( $ENV{REQUEST_URI} =~ /check/ ) ) {
    &redirect_to_home_page;
}

if ( $uri !~ /\// ) {
    $uri .= "/";
}

if ( $uri =~ /^www/i ) {
    $uri = "http://$uri";
}

#############################################################################
# Output validation results
#############################################################################

$header = <<"EOF";
Content-Type: text/html

$html40t_doctype
<html>

  <head>
    <title>W3C HTML Validation Service Results</title>
    <link rev="made" href="mailto:gerald\@w3.org">
  </head>

  <body bgcolor="#FFFFFF" text="#000000" link="#0000ee" vlink="#551a8b">

  <p>
    <a href="http://www.w3.org/"><img
       src="http://www.w3.org/Icons/WWW/w3c_home" height=48 border=0
       alt="W3C"></a>
  </p>

  <h1><a href="/">W3C HTML Validation Service</a> Results</h1>

$notice$debugmessage
EOF

if ( $uri !~ m#^http://# ) {
     print $header;
     print <<"EOF";
<p>
  Sorry, this type of URI is not supported by this service.
</p>

<p>
  URIs should be in the form:
</p>

<blockquote>
  <code>$abs_svc_uri</code>
</blockquote>

<p>
  (There are other types of URIs, too, but only <code>http://</code> URIs
  are currently supported by this service.)
</p>

EOF

    &clean_up_and_exit;
}

$ua = new LWP::UserAgent;
$ua->agent( "W3C_Validator/$revision " . $ua->agent );
$ua->parse_head(0);  # we want to parse the http-equiv stuff ourselves, for now
$request = new HTTP::Request(GET => $uri);

# if we got a Authorization header from the client, it means
# that the client is back at it after being prompted for
# a password: let's insert the header as is in the outgoing request
if($ENV{HTTP_AUTHORIZATION}){
    $request->headers->header(Authorization => $ENV{HTTP_AUTHORIZATION});
}

$response = $ua->request($request);

if ( $response->code != 200 ) {
    $optionstring = &build_options;
    if ( $response->code == 401 ) {
	$response->headers->www_authenticate =~ /Basic realm=\"([^\"]+)\"/;
	my $realm = $1;
	my $resource = $response->request->url;
	my $authHeader = $response->headers->www_authenticate;
	&print_401_auth_required_message( $resource, $realm, $authHeader );
    }
    else {
	print $header;
	&print_unknown_http_error_message( $uri, $response->code,
	    $response->message );
    }
    &clean_up_and_exit;
}

$content_type = $response->headers->content_type;

if ( ( $content_type =~ /text\/xml/i ) ||
     ( $content_type =~ /application\/xml/i ) ) {
    $xml = 1;
}
elsif ($content_type =~ /text\/html/i) {
    $html = 1;
}
else {
    print $header;
    print <<"EOF";

<p>
  Sorry, I can't validate this document because its returned
  content-type was <code>$content_type</code>, which is not
  currently supported by this service.
</p>
EOF

    &clean_up_and_exit;
}

$jump_links = &build_jump_links;
$count = 1; # @@ should loop over many uris instead

print $header;
print <<"EOF";
<h2><a name="doc$count">Document Checked</a></h2>

$jump_links
EOF
    
@file = split '\n',$response->content;
if ( $html || $xhtml ) {
    ( $guessed_doctype, $doctype ) = &check_for_doctype( \@file );
}

if ( $doctype =~ /xhtml/i ) {
    $xhtml = 1;
}

foreach $line (@file) {
    # @@ needs to handle meta elements that span more than one line
    if ( $line =~ /<meta/i ) {
	if ( $line =~ /charset\s*=[\s"]*([^\s;">]*)/i ) {
	    $meta_charset = $1;
	    last;
	}
    }
}

( $http_charset ) = ( $content_type =~ /;\s*charset=(.*)/i );
$content_type =~ s/;.*$//;
$content_type =~ s/\s*$//g;
$http_charset =~ s/;.*//;
$http_charset =~ s/\s*//g;

if ( $http_charset ne '' ) {
    $effective_charset = $http_charset;
    if ( $meta_charset ne '' && $http_charset !~ /$meta_charset/i ) {
    	    # @@ the above needs work
        $charsets_differ = 1;
    }
}
else {
    if ( $meta_charset ne '' ) {
        $effective_charset = $meta_charset;
    }
    else {
        $effective_charset = "unknown";
    }
}

if ( $effective_charset =~ /iso-2022-jp/i ) {
    $codeconv = "$nkf -Jex | ";
}
elsif ( $effective_charset =~ /Shift_JIS/i ) {
    $codeconv = "$nkf -Sex | ";
}
else {
    $codeconv = "";
}

print qq{<ul>\n  <li><a href="$uri_def_uri">URI</a>: <a href="$uri">$uri</a>\n};

if ( $lastmod = $response->headers->header("Last-Modified") ) {
    print qq{  <li>Last modified: $lastmod\n};
}

if ( defined $response->headers->server ) {
    print "  <li>Server: " . $response->headers->server . "\n";
}

if ( defined $response->content_length ) {
    print "  <li>Content length: " . $response->content_length . "\n";
}

if ( $xhtml ) {
    $ENV{SP_CATALOG_FILES} = "$sgmlstuff/PR-xhtml1-19990824/xhtml.soc";
    $ENV{SGML_SEARCH_PATH} = "$sgmlstuff/PR-xhtml1-19990824/";
    $ENV{SP_CHARSET_FIXED}="YES";
    $ENV{SP_ENCODING}="XML";
    $xmlflags = "-wxml ";
    $decl = $xhtmldecl;
}
elsif ( $xml ) {
    $ENV{SP_CATALOG_FILES} = "$sgmlstuff/sp-1.3/pubtext/xml.soc";
    $ENV{SGML_SEARCH_PATH} = "$sgmlstuff/sp-1.3/pubtext/";
    $ENV{SP_CHARSET_FIXED}="YES";
    $ENV{SP_ENCODING}="XML";
    $xmlflags = "-wxml -wno-valid ";
    $decl = $xmldecl;
}
else {			# must be HTML (for now)
    $decl = $sgmldecl;
    $catalog = "-c $sgmlstuff/catalog";
}

$command  = "$codeconv $sp -E0 $xmlflags $catalog $decl";

# print "  <li>nsgmls command line: <code>$command</code>\n";

open( CHECKER, "| $command - >$temp.esis 2>$temp" )
	|| die "couldn't open checker: $!";

print CHECKER "$doctype\n" if $guessed_doctype;
# this is a kludge for DOS users with their entire file on a single line
# like http://bogo.w3.org/test/samuels.html
if ( $#file == 0 ) {
    @file = (split(//,$file[0]));
    for (0..$#file) {
	$file[$_] .= "\n";
    }
}
# kludge for other DOS users with CRLFs
for (@file) {
    s/+$//;
    print CHECKER $_, "\n";
}
close( CHECKER ) || "couldn't close checker";

open( ERRORS, "< $temp" )	|| die "couldn't open checker results: $!";
@errors = <ERRORS>;
close( ERRORS )			|| die "couldn't close checker results: $!";

open( ESIS, "$temp.esis" )	|| die "couldn't read parser output: $!";
while (<ESIS>) {
    next if / IMPLIED$/;
    next if /^ASDAFORM CDATA /;
    next if /^ASDAPREF CDATA /;
    push(@esis,$_);
}
close( ESIS )			|| die "couldn't close parser output: $!";

$version = "unknown";
if ( $xhtml ) {
    $fpi = $doctype;
}
elsif ( $xml ) {
    $fpi = "XML";
}
else {
    for (@esis) {
	next unless /^AVERSION CDATA (.*)/;
	$fpi = $1;
	last;
    }
    if ( ! defined $fpi && length( $doctype) ) {
	    # this is needed for HTML 4 strict, which doesn't have a
	    # version attribute on the HTML element
        $fpi = $doctype;
    }
}
$version = $pub_ids{$fpi} || "unknown";

if ( $guessed_doctype ) {
    push( @fake_errors, "nsgmls:<OSFD>0:2:1:E: Missing DOCTYPE declaration at start of document (${lt}a href=\"http://www.htmlhelp.org/tools/validator/doctype.html\"${gt}explanation...${lt}/a${gt})\n" );
}

if ( $guessed_doctype ) {
    $escaped_doctype = $doctype;
    $escaped_doctype =~ s/" "/"\n            "/;
    $escaped_doctype =~ s/&/\&amp;/g;
    $escaped_doctype =~ s/</\&lt;/g;
}

print qq{  <li>Character encoding: $effective_charset\n};

if ( $charsets_differ ) {
    print <<"EOHD";
<br>
  <strong>Warning:</strong> the character encoding specified in the HTTP header
  (<code>$http_charset</code>) is different from the one specified in the META
  element (<code>$meta_charset</code>).
  I will use <code>$effective_charset</code> for this validation.

EOHD

}

print "  <li>Document type: <b>$version</b>.\n";

print "</ul>\n\n";

if ( $xml ) {
print <<"EOHD";
  <p>
    <strong>Note: experimental XML support was added to this service
    on Aug 31, 1999, but it isn't quite working yet; stay tuned to <a
    href="http://lists.w3.org/Archives/Public/www-validator/">the
    <code>www-validator</code> mailing list</a> for updates, and
    please don't trust this service's output for XML documents
    in the meantime.</strong>
  </p>
EOHD

}

print <<"EOHD";
  <p>
    Below are the results of attempting to parse this document with
    an SGML parser.
  </p>

EOHD

if ( $? || $guessed_doctype ) {
    print "<pre>\n";
    for ((@fake_errors,@errors)) {
	next if /^<OSFD>0:[0-9]+:[0-9]+:[^A-Z]/;
	next if / numbers exceeding 65535 not supported$/;
	next if $xhtml && /:W: SGML declaration was not implied$/;
	s/.*<OSFD>//g;
	if ( ! (($line, $col, $type, $msg)=(/^[^:]*:([0-9]+):([0-9]+):([A-Z]?):? (.*)/))) {
	    print "Uh oh! I got the following unknown error:\n\n   $_\n\n";
	    print "Please make sure you specified the DOCTYPE properly!\n\n";
	    &output_doctype_spiel;
	    last;
	}
	if ( $msg =~ /^cannot generate system identifier for entity / ) {
	    print "   <b>Fatal error</b>! $msg\n";
	    print "</pre>\n<p>I couldn't parse this document, because it " .
		  "uses a public\n    identifier that's not in my <a\n " .
		  "    href=\"sgml-lib/catalog\">catalog</a>!\n  </p>\n";
	    &output_doctype_spiel;
	    print "<pre>";	# so the </pre> we print later gets re-started
	    last;
	}
	if ( $msg =~ /^cannot open / ) {
	    print "   Fatal error! $msg\n";
	    print "</pre>\n<p>I couldn't parse this document, because it " .
		  "makes reference to\n    a system-specific file instead of " .
		  "simply using a public identifier\n    to specify the " .
		  "level of HTML being used.\n  </p>\n";
	    &output_doctype_spiel;
	    print "<pre>";	# so the </pre> we print later gets re-started
	    last;
	}
	$extraspaces = "";	# in case we put "(truncated)" gif on LHS
	$line-- if $guessed_doctype;
	$newline = $file[$line-1];
	$newline .= "\n";

	# make sure there's no ^P or ^Q's in the file, since we need to use
	# them to represent '<' and '>' temporarily.
	$newline =~ s/${lt}/P/go; $newline =~ s/${gt}/Q/g;

	if ( length( $newline ) > 70 ) {
	    if ( $col < 25 ) {
		# truncate source line at 70 chars (truncate right side only)
		$newline = substr( $newline, 0, 70 ) . "$contchars" . "\n";
	    }
	    elsif ( $col > 70 ) {
		# keep rightmost 70 chars; adjust $col accordingly
		# (truncate left side only)
		$diff = $col - 50;
		$newline = "$contchars" . substr( $newline, $diff, 70 );
		if ( length( $newline ) == (70 + length( "$contchars" )) ) {
		    $newline .= "$contchars" . "\n";
		}
		if ( $col > $diff ) {
		    $col -= $diff;
		}
		else {
		    $col -= 70;
		}
		$extraspaces = " " x 8;
	    }
	    else {
		# truncate source line on both sides; leave more source text
		# on left, and about 30 chars on right side. Also, adjust $col.
		if ( $col < 35 ) {
		    $newline = "$contchars" . substr( $newline, 0, 60 );
		}
		else {
		    $newline = "$contchars" . substr( $newline, $col - 35, 60 );
		    $col = 35;
		}
		if ( length( $newline ) == ( 60 + length( "$contchars" ))) {
		    $newline .= "$contchars" . "\n";
		}
		$extraspaces = " " x 8;
	    }
	}

	# figure out the index into the %frag associative array for the
	# "explanation..." links to the KGV FAQ.
	$msgindex = $msg;
	$msgindex =~ s/"[^"]+"/FOO/g;
	$msgindex =~ s/[^A-Za-z ]//;

	$out = "${lt}hr${gt}\n\nError at line $line:\n   $newline";
	if ( length( $msg ) < $col ) {    # does it fit in front?
	    $out .= "$extraspaces " . ' ' x ($col-length($msg)) .
		"$msg $rightarrow";
	}
	else {
	    if ( ( length( $msg ) + $col ) > 60 ) {
		if ( $msg =~ /,/ ) {
		    $msg =~ s/,/,\n         /;
		}
		else {
		    if ( ( (length( $msg ) / 2) + $col ) > 60 ) {
			$pos = index( $msg, ' ', length($msg)/4 );
			$indent = " " x (65-length($msg)*3/4);
		    }
		    else {
			$pos = index( $msg, ' ', length($msg)/2 );
			$indent = " " x ($col + 4);
		    }
		    $msg = substr( $msg, 0, $pos ) .
			"\n$indent" . substr( $msg, $pos );
		}
	    }
	    $out .= "$extraspaces   " . ' ' x ($col-1) . "$leftarrow $msg";
	}

	if ( defined $frag{$msgindex} ) {
	    $out .=
  " (${lt}a href=\"$faqerrloc#$frag{$msgindex}\"${gt}explanation...${lt}/a${gt})";
	}
	else { # remember msgindexes without frags, to get the KGV FAQ updated.
	    $undef_frag{$msgindex} = 1;
	}

	$out .= "\n";
	$out =~ s/&/&amp;/go; $out =~ s/</&lt;/go; $out =~ s/>/&gt;/go;
# the following kludge is so the <img src>s don't get sgml-proofed above
	$out =~ s/${lt}/</g; $out =~ s/${gt}/>/g;
	print $out;
    }
    print "</pre>\n";
    print "<hr>\n";
    if ( $version eq "unknown" ) {
	print "\n  <p>\n    Sorry, I can't validate this document.\n  </p>\n";
    }
    else {
	print "\n  <p>\n    Sorry, this document does not validate as $version.\n  </p>\n";
    }
    $validity="invalid";
}
else {
    print "\n  <pre>\n    No errors found!</pre>\n\n";
    if ( $version ne "unknown" ) {
	if ( $version =~ /^HTML 2\.0$/ ) {
	    $gifname = "vh20.gif";
	    $alttext = "Valid HTML 2.0!";
            $gifborder = "";
	}
	elsif ( $version =~ /HTML 3\.2</ ) {
	    $gifname = "vh32.gif";
	    $alttext = "Valid HTML 3.2!";
            $gifhw   = " height=31 width=88";
	}
	elsif ( $version =~ /HTML 4\.0<\/a>$/ ) {
	    $gifname = "vh40.gif";
	    $alttext = "Valid HTML 4.0!";
            $gifborder = "";
            $gifhw   = " height=31 width=88";
	}
	elsif ( $version =~ /HTML 4\.0<\/a> / ) {
	    $gifname = "vh40.gif";
	    $alttext = "Valid HTML 4.0!";
            $gifhw   = " height=31 width=88";
	}
	elsif ( $version =~ /HTML 4\.01<\/a>$/ ) {
	    $gifname = "vh40.gif";
	    $alttext = "Valid HTML 4.01!";
            $gifborder = "";
            $gifhw   = " height=31 width=88";
	}
	elsif ( $version =~ /HTML 4\.01<\/a> / ) {
	    $gifname = "vh40.gif";
	    $alttext = "Valid HTML 4.01!";
            $gifhw   = " height=31 width=88";
	}
	elsif ( $version =~ /HTML 3\.0/ ) {
	    $gifname = "vh30.gif";
	    $alttext = "Valid HTML 3.0!";
	}
	elsif ( $version =~ /Netscape/ ) {
	    $gifname = "vhns.gif";
	    $alttext = "Valid Netscape-HTML!";
	}
	elsif ( $version =~ /Hotjava/ ) {
	    $gifname = "vhhj.gif";
	    $alttext = "Valid Hotjava-HTML!";
	}
	if ( defined $gifname ) {
	    $nicegifname = $gifname;
	    $nicegifname =~ s/</\&lt;/g; $nicegifname =~ s/&/\&amp;/g;
	    print <<"EOHD";
  <p>
    <img src="$rel_img_uri$gifname" alt="$alttext"> Congratulations, this
    document validates as $version!
  </p>

  <p>
    To show your readers that you've taken the care to create an
    interoperable Web page, you may display this icon on any page
    that validates. Here is the HTML you could use to add this icon
    to your Web page:
  </p>
  <pre>
  &lt;p&gt;
    &lt;a href="$abs_svc_uri"&gt;&lt;img$gifborder
        src="$abs_img_uri$nicegifname"
        alt="$alttext"$gifhw&gt;&lt;/a&gt;
  &lt;/p&gt;</pre>
  <p>
    If you like, you can <a href="$rel_img_uri$gifname">download a copy of this
    image</a> to keep in your local web directory, and change the HTML fragment
    above to reference your local image rather than the one on this server.
  </p>
EOHD
	}
    }
    if ( ( $version eq "unknown" ) || ( ! defined $gifname ) ) {
	print "  <p>\n    Congratulations, this document validates as the document type specified! (I don't have an icon for this one yet, sorry.)\n  </p>\n";
    }

    $escaped_uri = $uri;
    $escaped_uri =~  s/=/%3D/g;
    $escaped_uri =~ s/\&/%26/g;
    $escaped_uri =~  s/;/%3B/g;
    $escaped_uri =~  s/,/%2C/g;
	# ugh

    $thispage = "${abs_svc_uri}check?uri=$escaped_uri";
    $thispage .= &build_options;
    print <<"EOHD";

  <p>
    If you would like to create a link to <em>this</em> page (i.e., this
    validation result) to make it easier to re-validate this page in the
    future or to allow others to validate your page, the URI is:
  </p>

  <blockquote>
    <code>$thispage</code>
  </blockquote>

  <p>
    (Or, you can just add the current page to your bookmarks or hotlist.)
  </p>

EOHD

    $validity="valid";
}

$validation_return_code = $?;

if ( $FORM{"weblint"} eq "true" ) {

    if ( $FORM{"pw"} eq "true" ) {
	$pedanticflags = "-pedantic -e mailto-link";
	$pedantic_blurb = " (in \"pedantic\" mode)";
    }
    else {
	$pedanticflags = "";
    }

    print <<"EOF";
  <hr>
  <h2><a name="weblint">Weblint Results</a></h2>

  <p>
    Below are the results of running <a
    href="http://www.cre.canon.co.uk/~neilb/weblint/">Weblint</a>
    on this document$pedantic_blurb:
  </p>
EOF

    open( WEBLINT,
	"| $weblint -s $pedanticflags - 2>&1 >$temp.weblint" )
	    || die "couldn't open weblint: $!";
    for (@file) {
	print WEBLINT $_, "\n";
    }
    close( WEBLINT ) || "couldn't close weblint: $!";

    print "\n\n";
    if ( $? ) {
	print "  <ul>\n";

	    open( WEBLINTOUT, "$temp.weblint" )
		|| die "couldn't open weblint results in $temp: $!";

	    while (<WEBLINTOUT>) {
		s/ \(use "-x <extension>" to allow this\)\.$/./go;
		s/&/&amp;/go;
		s/</&lt;/go;
		s/>/&gt;/go;
		print "    <li>$_";
	    }

	    close( WEBLINTOUT ) || die "couldn't close weblint results: $!";
	    print "  </ul>\n";
    }
    else {
	print "\n  <blockquote>\n    Looks good to me!\n  </blockquote>\n";
    }
    print "\n\n";
}

if ( $FORM{"outline"} eq "true" ) {
    print <<'EOF';
  <hr>
  <h2><a name="outline">Outline</a></h2>

  <p>
    Below is an outline for this document, automatically generated from the
    heading tags (<code>&lt;H1&gt;</code> through <code>&lt;H6&gt;</code>.)
  </p>
EOF

    $prevlevel = 0;
    $indent = 0;
    for (1..$#esis) {
	$line = $esis[$_];
	next if / IMPLIED$/;
	next if /^ASDAFORM CDATA /;
	next if /^ASDAPREF CDATA /;
	next unless $line =~ /^\(H[1-6]$/;
	$prevlevel = $level;
	$level = substr( $line, 2, 1 );

	print "    </ul>\n" x ( $prevlevel - $level     );  # perl is so cool.
	if ( $level - $prevlevel == 1 ) {
	    print "    <ul>\n";
	}
	foreach $i ( ($prevlevel+1) .. ($level-1)) {
	    print "  <ul>\n    <li><em>A level $i heading is missing!</em>\n";
	}
	if ( $level - $prevlevel > 1 ) {
	    print "    <ul>\n";
	}

	$line = "foo"; $heading = "";
	while ( substr( $line, 0, 3 ) ne ")H$level" ) {
	    $line = $esis[$_++];
	    if ( $line =~ /^-/ ) {
		$headcont = $line;
		substr( $headcont, 0, 1 ) = " ";
		$headcont =~ s/\\n/ /g;
		$heading .= $headcont;
	    }
	}

	$heading = substr( $heading, 1 );	# chop the leading '-'
	$heading =~ s/&/&amp;/go; $heading =~ s/</&lt;/go;

	print "    <li>$heading";
    }
    print "    </ul>\n" x ( $level );
    print <<'EOF';
    <p>
      If this doesn't look like a real outline, it is likely that the
      heading tags are not being used properly. (Headings should reflect
      the logical structure of the document; they should not be used simply
      to add emphasis, or to change the font size.)
    </p>
EOF
}

if ( $FORM{"ss"} eq "true" ) {
    print <<'EOF';
  <hr>
  <h2><a name="source">Source Listing</a></h2>

  <p>
    Below is the source input I used for this validation:
  </p>
EOF

    print "<pre>\n";
    if ( $guessed_doctype ) {
	$gd = "$doctype\n";
	$gd =~ s/&/&amp;/go; $gd =~ s/</&lt;/go;
	printf "%4d: %s", 0, $gd;
    }
    $line = 1;
    for (@file) {
	s/&/&amp;/go; s/</&lt;/go;
	printf "%4d: %s\n", $line, $_;
	$line++;
    }
    print "</pre>\n";
}

if ( $FORM{"sp"} eq "true" ) {
    print <<'EOF';
  <hr>
  <h2><a name="parse">Parse Tree</a></h2>

  <p>
    Below is the parse tree for this document. <em>Note: this feature is
    still under construction! I'm trying to make this easier to read
    somehow, with little success.
EOF

    if ( $FORM{"noatt"} ne "true" ) {
	print <<'EOF';
    It helps a bit if you select the
    "don't show attributes" option on the <a href="./#byURI">form</a>.
EOF
    }
    print "</em>\n  </p>\n\n";

    if ( $FORM{"noatt"} eq "true" ) {
	print <<'EOF';
    <p>
      I'm excluding the attributes, as you requested.
    </p>
EOF
    }

    $indent = 0;
    print "<pre>\n";
    for (@esis) {
	if ( $FORM{"noatt"} eq "true" ) {
	    next if /^A/;
	    next if /^\(A$/;
	    next if /^\)A$/;
	}

# experimental: skip data if it's only newlines and space.
# next if /^-(\\n|\s+)*$/;

# another way to do the same thing:
# experimental: skip data if it's only newlines and space.
s/\\n/ /g; s/\\011/ /g; s/\s+/ /g;
next if /^-\s*$/;

if ( /^-/ ) {
    chop;
    substr( $_, 0, 1 ) = " ";
# $_ = substr( $_, 1 );	# experimental. previous line works OK.
    $prevdata .= $_;
    next;
}
else {
    $prevdata =~ s/&/&amp;/go;
    $prevdata =~ s/</&lt;/go;
    $prevdata =~ s/\s+/ /go;
# should wrap this to 80 columns or whatever. check tchrist's wrapping hack from c.l.p.m.
    print " " x $indent . "$prevdata\n";
    undef $prevdata;
}
# end of experimental stuff


#	next unless /^AHREF CDATA /;	# this is interesting when uncommented
	s/&/&amp;/go;
	s/</&lt;/go;
	if ( /^\)/ ) {
	   $indent -= 3;
	}

	chop( $printme = $_ );
	$printme =~ s/^\((.*)/&lt;$1&gt;\n/;
	$printme =~ s/^\)(.*)/&lt;\/$1&gt;/;
	print " " x $indent . "$printme";
#	print " " x $indent . "$_";

	if ( /^\(/ ) {
	   $indent += 3;
	}
    }
    print "</pre>\n";
}

&clean_up_and_exit;

sub output_doctype_spiel {

    print <<"EOF";

    <p>
      You should make the first line of your HTML document a DOCTYPE
      declaration, like this:
    </p>

    <pre>
      &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN"&gt;
      &lt;HTML&gt;
	&lt;HEAD&gt;
	  &lt;TITLE&gt;Title&lt;/TITLE&gt;
	&lt;/HEAD&gt;

	&lt;BODY&gt;
	  &lt;-- ... body of document ... --&gt;
	&lt;/BODY&gt;
      &lt;/HTML&gt;</pre>

    <p>
      Or, if you are using features from <a
      href="http://www.w3.org/TR/REC-html40/">HTML 4.0</a>,
      one of these:
    </p>

    <pre>
      &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"&gt;
      &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;
      &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN"&gt;</pre>

EOF

}

sub output_closing {

    print <<"EOF";

<hr>

<address>
  <a href="http://validator.w3.org/check/referer"><img
     src="http://validator.w3.org/images/vh40.gif" height=31 width=88
     align=right border=0 alt="Valid HTML 4.0!"></a>
  <a href="/feedback.html">Gerald Oskoboiny</A><br>
  $cvsdate
</address>

</body>

</html>
EOF

}

sub build_options {

    $optionstring = "";
    foreach $option (@options) {
        $optionstring .= ";$option" if $FORM{$option} eq "true";
    }
    $optionstring;

}

sub erase_stuff {

    unlink $temp;
    unlink "$temp.esis";
    unlink "$temp.weblint";

}

sub make_log_entry {

    open(LOG,">>$logfile") || die "couldn't append to log: $!";
    print LOG "$ENV{REMOTE_HOST}\t$validity $version\t$uri\n";
    foreach $msgindex (keys %undef_frag) {
	print LOG "frag not defined for msgindex: $msgindex\n";
    }
    close( LOG ) || die "couldn't close log: $!";

}

sub clean_up_and_exit {

    &output_closing;
    &erase_stuff;
#    &make_log_entry;
    exit;

}

sub redirect_to_home_page {

    print "Status: 302 Moved Permanently\n";
    print "Content-Type: text/html\n";
    print "Location: http://validator.w3.org/\n\n";
    print "<title>Moved!</title>\n";
    print "<p>\n";
    print "  Please see <a href=\"http://validator.w3.org/\">the validation service's home page.</a>\n";
    print "</p>\n";

    &clean_up_and_exit;

}

sub build_jump_links {

    my $text;
    my $count = 0;

    $count++ if $FORM{ss}      eq "true";
    $count++ if $FORM{sp}      eq "true";
    $count++ if $FORM{weblint} eq "true";
    $count++ if $FORM{outline} eq "true";

    if ( $count ) {
	$text .= "  <p>\n    Jump to: ";
	if ( $FORM{"weblint"} eq "true" ) {
	    $text .= "<a\n      href=\"#weblint\">Weblint Results</a>";
	    $count--;
	    $text .= " or " if ( $count == 1 );
	    $text .= ", "   if ( $count >  1 );
	}
	if ( $FORM{"outline"} eq "true" ) {
	    $text .= "<a\n      href=\"#outline\">Outline</a>";
	    $count--;
	    $text .= " or " if ( $count == 1 );
	    $text .= ", "   if ( $count >  1 );
	}
	if ( $FORM{"ss"} eq "true" ) {
	    $text .= "<a\n      href=\"#source\">Source Listing</a>";
	    $count--;
	    $text .= " or " if ( $count == 1 );
	    $text .= ", "   if ( $count >  1 );
	}
	if ( $FORM{"sp"} eq "true" ) {
	    $text .= "<a\n      href=\"#parse\">Parse Tree</a>";
	}
	$text .= ".\n  </p>\n\n";
    }
    return $text;

}

sub check_for_doctype {
    # check if the document has a doctype; if it doesn't, try to
    # guess an appropriate one given the elements used
    #
    # returns 2 values:
    #
    # first value: 0 or 1:
    #     if 0, there was a doctype already present;
    #     if 1, there wasn't a doctype
    #
    # second value:
    #     the inferred doctype, if any

    my $fileref = shift;		# a reference to @file, for efficiency
    my @file = @$fileref;		# dereference $fileref

    foreach $count (0..$#file) {
	$line = $file[$count];

	# does an HTML element precede the doctype on the same line?
	last if $line =~ /<[a-z].*<!doctype/i;

	if ( $line =~ /<!doctype/i ) {	# found a doctype
	    $dttext = join( "", @file[$count..$count+5] );
	    $dttext =~ s/\n//g;
	    $dttext =~ s/.*doctype\s+html\s+public\s*"//i;
	    $dttext =~ s/".*//;	# strip everything except the FPI
	    return 0, $dttext;
	}

	$line =~ s/<!(?:--(?:[^-]|-[^-])*--\s*)+>//go;	# strip comments,
	    # so the next line doesn't find commented-out markup etc.
	    # (this doesn't handle multi-line comments, unfortunately)

	last if ( $line =~ /<[a-z]/i );		# found an element
    
    }

    # do several loops of increasing lengths to avoid iterating over
    # the whole file if possible.
    #
    # these heuristics could be improved a lot.

    foreach $line (@file[0..20]) {
	return 1, $xhtmlt_doctype if $line =~ /xmlns\s*=/i;
    }

    foreach $line (@file[0..20]) {
	return 1, $html40f_doctype if $line =~ /<frame/i;
    }

    foreach $line (@file[0..20]) {
	return 1, $html40t_doctype if $line =~ /<(table|body )/i;
    }

    # go through the whole file
    foreach $line (@file) {
	return 1, $html40t_doctype if $line =~ /<(table|body )/i;
    }

    foreach $line (@file) {
	return 1, $html32_doctype if $line =~ /<center>/i;
	return 1, $html32_doctype if $line =~ /<[h0-9p]*\s*align\s*=\s*center>/i;
    }

    # no luck earlier; guess HTML 4.0 transitional
    return 1, $html40t_doctype;

}

sub print_401_auth_required_message {

    my $resource = shift;
    my $realm = shift;
    my $authHeader = shift;

    print <<"EOF";
Status: 401 Authorization Required
WWW-Authenticate: $authHeader
Connection: close
Content-Type: text/html

<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">
<HTML><HEAD>
<TITLE>401 Authorization Required</TITLE>
</HEAD><BODY>
<H1>Authorization Required</H1>
<p>
  Sorry, I am not authorized to access the specified URI.
</p>

<p>
  The URI you specified,
</p>

<blockquote>
  <code><a href="$resource">$resource</a></code>
</blockquote>

<p>
  returned a 401 "authorization required" response when I tried
  to download it.
</p>

<p>
  You should have been prompted by your browser for a
  username/password pair; if you had supplied this information, I
  would have forwarded it to your server for authorization to
  access the resource. You can use your browser's "reload" function
  to try again, if you wish.
</p>

<p>
  Of course, you may not want to trust me with this information,
  which is fine. I can tell you that I don't log it or do
  anything else nasty with it, and you can <a
  href="http://validator.w3.org/source/">download the source for
  this service</a> to see what it does, but you have no guarantee
  that this is actually the code I'm using; you basically have to
  decide whether to trust me or not. :-)
</p>

<p>
  Note that you shouldn't use HTTP Basic Authentication for
  anything which really needs to be private, since the password
  goes across the network unencrypted.
</p>
EOF

}

sub print_unknown_http_error_message {

    my $uri = shift;
    my $code = shift;
    my $message = shift;

    print <<"EOF";
  <p>
    I got the following unexpected response when trying to
    retrieve <code><a href="$uri">$uri</a></code>:
  </p>

  <blockquote>
    <code>$code $message</code>
  </blockquote>

  <p>
    Please make sure you have entered the URI correctly.
  </p>

EOF

}

